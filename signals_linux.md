# Signals Supported by Linux

| Signal    | Description                                                                      | Default action           |
| --------- | -------------------------------------------------------------------------------- | ------------------------ |
| SIGABRT   | Sent by abort( )                                                                 | Terminate with core dump |
| SIGALRM   | Sent by alarm( )                                                                 | Terminate                |
| SIGBUS    | Hardware or alignment error                                                      | Terminate with core dump |
| SIGCHLD   | Child has terminated                                                             | Ignored                  |
| SIGCONT   | Process has continued after being stopped                                        | Ignored                  |
| SIGFPE    | Arithmetic exception                                                             | Terminate with core dump |
| SIGHUP    | Process's controlling terminal was closed (most frequently, the user logged out) | Terminate                |
| SIGILL    | Process tried to execute an illegal instruction                                  | Terminate with core dump |
| SIGINT    | User generated the interrupt character (Ctrl-C)                                  | Terminate                |
| SIGIO     | Asynchronous I/O event                                                           | Terminate<sub>[1]</sub>  |
| SIGKILL   | Uncatchable process termination                                                  | Terminate                |
| SIGPIPE   | Process wrote to a pipe but there are no readers                                 | Terminate                |
| SIGPROF   | Profiling timer expired                                                          | Terminate                |
| SIGPWR    | Power failure                                                                    | Terminate                |
| SIGQUIT   | User generated the quit character (Ctrl-\)                                       | Terminate with core dump |
| SIGSEGV   | Memory access violation                                                          | Terminate with core dump |
| SIGSTKFLT | Coprocessor stack fault                                                          | Terminate<sub>[2]</sub>  |
| SIGSTOP   | Suspends execution of the process                                                | Stop                     |
| SIGSYS    | Process tried to execute an invalid system call                                  | Terminate with core dump |
| SIGTERM   | Catchable process termination                                                    | Terminate                |
| SIGTRAP   | Break point encountered                                                          | Terminate with core dump |
| SIGTSTP   | User generated the suspend character (Ctrl-Z)                                    | Stop                     |
| SIGTTIN   | Background process read from controlling terminal                                | Stop                     |
| SIGTTOU   | Background process wrote to controlling terminal                                 | Stop                     |
| SIGURG    | Urgent I/O pending                                                               | Ignored                  |
| SIGUSR1   | Process-defined signal                                                           | Terminate                |
| SIGUSR2   | Process-defined signal                                                           | Terminate                |
| SIGVTALRM | Generated by setitimer( ) when called with the ITIMER_VIRTUAL flag               | Terminate                |
| SIGWINCH  | Size of controlling terminal window changed                                      | Ignored                  |
| SIGXCPU   | Processor resource limits were exceeded                                          | Terminate with core dump |
| SIGXFSZ   | File resource limits were exceeded                                               | Terminate with core dump |

<sub>[1]</sub> a The behavior on other Unix systems, such as BSD, is to ignore this signal.
<sub>[2]</sub> b The Linux kernel no longer generates this signal; it remains only for backward compatibility.

Several other signal values exist, but Linux defines them to be equivalent to other values:
SIGINFO is defined as SIGPWR,<sub>[3]</sub> SIGIOT is defined as SIGABRT, and SIGPOLL and SIGLOST are defined as SIGIO.

<sub>[3]</sub> * Only the Alpha architecture defines this signal. On all other machine architectures, this signal does not exist. 


## SIGABRT
The abort( ) function sends this signal to the process that invokes it. The process then terminates and generates a core file.In Linux, assertions such as assert( ) call abort( ) when the conditional fails.

## SIGALRM
The alarm( ) and setitimer( ) (with the ITIMER_REAL flag) functions send this signal to the process that invoked them when an alarm expires.

## SIGBUS
The kernel raises this signal when the process incurs a hardware fault other than memory protection, which generates a SIGSEGV. On traditional Unix systems, this signal represented various irrecoverable errors, such as unaligned memory access.
The Linux kernel, however, fixes most of these errors automatically, without generating the signal. The kernel does raise this signal when a process improperly accesses a region of memory created via mmap( ). Unless this signal is caught, the kernel will terminate the process, and generate a core dump.

## SIGCHLD
Whenever a process terminates or stops, the kernel sends this signal to the process' parent. Because SIGCHLD is ignored by default, processes must explicitly catch and handle it if they are interested in the lives of their children. A handler
for this signal generally calls wait( ).

## SIGCONT
The kernel sends this signal to a process when the process is resumed after being stopped. By default, this signal is ignored, but processes can catch it if they want to perform an action after being continued. This signal is commonly used by
terminals or editors, which wish to refresh the screen.

## SIGFPE
Despite its name, this signal represents any arithmetic exception, and not solely those related to floating-point operations. Exceptions include overflows, underflows, and division by zero. The default action is to terminate the process
and generate a core file, but processes may catch and handle this signal if they want. Note that the behavior of a process and the result of the offending operation are undefined if the process elects to continue running.

## SIGHUP
The kernel sends this signal to the session leader whenever the session's terminal disconnects. The kernel also sends this signal to each process in the foreground process group when the session leader terminates. The default action is to
terminate, which makes sense—the signal suggests that the user has logged out.
Daemon processes "overload" this signal with a mechanism to instruct them to reload their configuration files. Sending SIGHUP to Apache, for example, instructs it to reread httpd.conf. Using SIGHUP for this purpose is a common convention,
but not mandatory. The practice is safe because daemons do not have controlling terminals, and thus should never normally receive this signal.

## SIGILL
The kernel sends this signal when a process attempts to execute an illegal machine instruction. The default action is to terminate the process, and generate a core dump. Processes may elect to catch and handle SIGILL, but their behavior
is undefined after its occurrence.

## SIGINT
This signal is sent to all processes in the foreground process group when the user enters the interrupt character (usually Ctrl-C). The default behavior is to terminate; however, processes can elect to catch and handle this signal, and
generally do so to clean up before terminating.

## SIGIO
This signal is sent when a BSD-style asynchronous I/O event is generated. This style of I/O is rarely used on Linux.

## SIGKILL
This signal is sent from the kill( ) system call; it exists to provide system administrators with a surefire way of unconditionally killing a process. This signal cannot be caught or ignored, and its result is always to terminate the process.

## SIGPIPE
If a process writes to a pipe, but the reader has terminated, the kernel raises this signal. The default action is to terminate the process, but this signal may be caught and handled.

## SIGPROF
The setitimer( ) function, when used with the ITIMER_PROF flag, generates this signal when a profiling timer expires. The default action is to terminate the process.

## SIGPWR
This signal is system-dependent. On Linux, it represents a low-battery condition (such as in an uninterruptible power supply, or UPS). A UPS monitoring daemon sends this signal to init, which then responds by cleaning up and shutting down
the system—hopefully before the power goes out!

## SIGQUIT
The kernel raises this signal for all processes in the foreground process group when the user provides the terminal quit character (usually Ctrl-\). The default action is to terminate the processes, and generate a core dump.

## SIGSEGV
This signal, whose name derives from segmentation violation, is sent to a process when it attempts an invalid memory access. This includes accessing unmapped memory, reading from memory that is not read-enabled, executing
code in memory that is not execute-enabled, or writing to memory that is not write-enabled. Processes may catch and handle this signal, but the default action is to terminate the process and generate a core dump.

## SIGSTOP
This signal is sent only by kill( ). It unconditionally stops a process, and cannot be caught or ignored.

## SIGSYS
The kernel sends this signal to a process when it attempts to invoke an invalid system call. This can happen if a binary is built on a newer version of the operating system (with newer versions of system calls), but then runs on an older
version. Properly built binaries that make their system calls through glibc should never receive this signal. Instead, invalid system calls should return -1, and set errno to ENOSYS.

## SIGTERM
This signal is sent only by kill( ); it allows a user to gracefully terminate a process (the default action). Processes may elect to catch this signal, and clean up before terminating, but it is considered rude to catch this signal and not
terminate promptly.

## SIGTRAP
The kernel sends this signal to a process when it crosses a break point. Generally, debuggers catch this signal, and other processes ignore it.

## SIGTSTP
The kernel sends this signal to all processes in the foreground process group when the user provides the suspend character (usually Ctrl-Z).

## SIGTTIN
This signal is sent to a process that is in the background when it attempts to read from its controlling terminal. The default action is to stop the process.

## SIGTTOU
This signal is sent to a process that is in the background when it attempts to write to its controlling terminal. The default action is to stop the process.

## SIGURG
The kernel sends this signal to a process when out-of-band (OOB) data has arrived on a socket. Out-of-band data is beyond the scope of this book.

## SIGUSR1 and SIGUSR2
These signals are available for user-defined purposes; the kernel never raises them. Processes may use SIGUSR1 and SIGUSR2 for whatever purpose they like. A common use is to instruct a daemon process to behave differently. The default
action is to terminate the process.

## SIGVTALRM
The setitimer( ) function sends this signal when a timer created with the ITIMER_VIRTUAL flag expires.

## SIGWINCH
The kernel raises this signal for all processes in the foreground process group when the size of their terminal window changes. By default, processes ignore this signal, but they may elect to catch and handle it if they are aware of their
terminal's window size. A good example of a program that catches this signal is top—try resizing its window while it is running and watch how it responds.

## SIGXCPU
The kernel raises this signal when a process exceeds its soft processor limit. The kernel will continue to raise this signal once per second until the process exits, or exceeds its hard processor limit. Once the hard limit is exceeded, the kernel sends
the process a SIGKILL.

## SIGXFSZ
The kernel raises this signal when a process exceeds its file size limit. The default action is to terminate the process, but if this signal is caught or ignored, the system call that would have resulted in the file size limit being exceeded returns -
1, and sets errno to EFBIG.